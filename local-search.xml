<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>高数</title>
    <link href="/2023/01/04/%E9%AB%98%E6%95%B0/"/>
    <url>/2023/01/04/%E9%AB%98%E6%95%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2022/12/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/12/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><h3 id="0-1-参考书目"><a href="#0-1-参考书目" class="headerlink" title="0.1. 参考书目"></a>0.1. 参考书目</h3><ul><li>现代操作系统(Modern Operating System) (第4版)</li></ul><h2 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1. 进程与线程"></a>1. 进程与线程</h2><h3 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1. 进程"></a>1.1. 进程</h3><p>​我们假设进程之间彼此是有敌意的，他们可能所属不同的用户，会相互争夺资源或相互破坏。</p><p>​<strong>用户态能访问特定的寄存器，而非不能访问。</strong></p><h4 id="1-1-1-进程的创建"><a href="#1-1-1-进程的创建" class="headerlink" title="1.1.1. 进程的创建"></a>1.1.1. 进程的创建</h4><ul><li><p>导致进程创建的4种主要事件</p><ul><li><p>系统初始化</p></li><li><p>正在运行的程序执行了创建进程的系统调用</p></li><li><p>用户请求创建一个新的进程</p><p>​如交互式系统键入命令或点击图标</p></li><li><p>一个批处理作业的初始化</p><p>​仅在大型机的批处理系统中使用，用户可以提交批处理作业。当操作系统认为资源足够运行另一个作业时，它会新建一个进程并运行输入队列的下一个作业</p></li></ul></li><li><p>地址空间</p><ul><li>在UNIX中<ul><li>不可写的内存区是共享的</li><li>或者，子进程共享父进程的所有内存，但写时复制</li></ul></li><li>在Windows中，从一开始父进程的地址空间和子进程的地址空间就是不同的</li></ul></li></ul><h4 id="1-1-2-进程的终止"><a href="#1-1-2-进程的终止" class="headerlink" title="1.1.2. 进程的终止"></a>1.1.2. 进程的终止</h4><ul><li>进程终止的原因<ul><li>正常退出</li><li>出错退出，自愿</li><li>严重错误，非自愿</li><li>被其他进程杀死</li></ul></li></ul><h4 id="1-1-3-进程的层次结构"><a href="#1-1-3-进程的层次结构" class="headerlink" title="1.1.3. 进程的层次结构"></a>1.1.3. 进程的层次结构</h4><ul><li><p>在UNIX中，树状结构</p><ul><li><p>在启动时，init出现在启动映像中，读入一个说明终端数量的文件。接着为每一个终端创建一个新进程，等待用户登录。如果有一个用户登录成功则执行一个shell</p></li><li><p>进程和其子进程组成一个进程组，用户从键盘发出的信号(如Ctrl + C)被发送给当前与键盘相关的进程组中的所有成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">pid_t</span> <span class="hljs-title function_">getpgid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span>; <span class="hljs-comment">//获取pid的进程组(进程组名一般是某个进程pid)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setpgid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">pid_t</span> pgid)</span>;  <span class="hljs-comment">//设置进程组</span><br></code></pre></td></tr></table></figure><p>一个设置进程组例子如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-type">pid_t</span> pid;<br><br>    <span class="hljs-keyword">if</span>((pid = fork()) &lt; <span class="hljs-number">0</span>)&#123;<br>        perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child: pid:%d\tgroup id:%d\n&quot;</span>, getpid(), getpgid(<span class="hljs-number">0</span>));<br>        sleep(<span class="hljs-number">3</span>);<br>        setpgid(getpid(), getpid());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child after change: pid:%d\tgroup id:%d\n&quot;</span>, getpid(), getpgid(<span class="hljs-number">0</span>));<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent: pid:%d\tgroup id:%d\n&quot;</span>, getpid(), getpgid(<span class="hljs-number">0</span>));<br>        sleep(<span class="hljs-number">2</span>);<br>        wait(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Windows中，没有进程层次的概念，所有进程地位是相同的。</p><p>​创建进程时父进程会得到一个特殊的令牌(称为句柄)，可以控制子进程。令牌可以传送给其他进程</p></li></ul><h4 id="1-1-4-进程的状态"><a href="#1-1-4-进程的状态" class="headerlink" title="1.1.4. 进程的状态"></a>1.1.4. 进程的状态</h4><p>​注意哪些状态转换不存在(如阻塞不能直接运行)</p><ul><li><p>五状态</p><p><img src="https://cdn.jsdelivr.net/gh/tsdsnk/imgs@main/img/QQ%E6%88%AA%E5%9B%BE20230105210735.png" alt="五状态"></p></li><li><p>七状态</p><p><img src="https://cdn.jsdelivr.net/gh/tsdsnk/imgs@main/img/QQ%E6%88%AA%E5%9B%BE20230105210755.png" alt="七状态"></p></li></ul><h4 id="1-1-5-进程的实现"><a href="#1-1-5-进程的实现" class="headerlink" title="1.1.5. 进程的实现"></a>1.1.5. 进程的实现</h4><ul><li><p>操作系统维护着一张表格，即进程表。每个进程占用一个表项(也称进程控制块)，记录着进程的一些状态。</p></li><li><p>对于中断发生时:</p><ul><li><p>将进程信息压入堆栈，跳转到中断向量的地址。(这些任务由__硬件__完成)</p></li><li><p>(跳转到的软件)将堆栈中的信息保存到进程表项中，并删除堆栈中数据。</p></li><li><p>将堆栈指针指向进程处理程序所使用的临时堆栈</p></li><li><p>C语言编写的中断服务程序</p></li><li><p>调用调度程序</p></li><li><p>为当前的进程装入寄存器值以及内存映射。</p></li></ul></li></ul><h3 id="1-2-线程"><a href="#1-2-线程" class="headerlink" title="1.2. 线程"></a>1.2. 线程</h3><pre><code class="hljs">      线程同属于一个用户，因而对不同线程的资源进行保护是没有必要的。</code></pre><h4 id="1-2-1-线程的内容"><a href="#1-2-1-线程的内容" class="headerlink" title="1.2.1. 线程的内容"></a>1.2.1. 线程的内容</h4><table><thead><tr><th>线程共享的进程内容</th><th>每个线程中的内容</th></tr></thead><tbody><tr><td>地址空间</td><td>程序计数器</td></tr><tr><td>全局变量</td><td>寄存器</td></tr><tr><td>打开文件</td><td>堆栈</td></tr><tr><td>子进程</td><td>状态</td></tr><tr><td>即将发生的定时器</td><td></td></tr><tr><td>信号与信号处理程序</td><td></td></tr><tr><td>账户信息</td><td></td></tr></tbody></table><p>​每个线程都有自己独立的堆栈，否则函数调用过程会出现混乱。</p><h4 id="1-2-2-POSIX线程"><a href="#1-2-2-POSIX线程" class="headerlink" title="1.2.2. POSIX线程"></a>1.2.2. POSIX线程</h4><p>​该标准定义的线程包叫__pthread__，大部分UNIX系统均支持该标准</p><p>​一个例子如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_param</span>&#123;</span><br>    <span class="hljs-type">int</span> param1;<br>    <span class="hljs-type">int</span> param2;<br>&#125;Param;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">thread_func</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span>&#123;<br>    Param param = *(Param *)arg;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello from thread\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Get param: param1:%d\tparam2:%d\n&quot;</span>, param.param1, param.param2);<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    Param param;<br>    param.param1 = <span class="hljs-number">1</span>;<br>    param.param2 = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, thread_func, (<span class="hljs-type">void</span> *)&amp;param) != <span class="hljs-number">0</span>)&#123;<br>        perror(<span class="hljs-string">&quot;pthread_creat&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-3-线程的实现"><a href="#1-2-3-线程的实现" class="headerlink" title="1.2.3. 线程的实现"></a>1.2.3. 线程的实现</h4><ul><li><p>在用户空间实现</p><ul><li><p>从内核角度:</p><p>​单线程进程</p><p>在用户空间:</p><p>​存在一个运行时系统，运行时系统管理着线程表，线程在运行时系统的上层运行</p></li><li><p>优点</p><ul><li>线程调度较为快捷，因为无需陷入内核</li><li>允许每个进程有自己定制的调度算法</li><li>具有较好的扩展性。否则内核空间维护线程信息，在线程数较大时会出现问题</li></ul></li><li><p>缺点</p><ul><li><p>如何实现阻塞系统调用。阻塞系统调用会阻塞进程，即全部线程。</p><p>一种可能的替代方案:</p><p>​select系统调用可以允许调用者预知是否会引起阻塞。在系统周围从事检查的这类代码被称为__包装器__。但这个做法效率并不高。(大部分使用多线程的原因是经常会发生线程阻塞)</p></li><li><p>类似于阻塞的问题:缺页中断</p></li><li><p>线程必须主动放弃(yield)，否则其他线程会无法运行。</p><p>​因为在进程内部并没有时钟中断。一种方案是让运行时系统每秒请求一次时钟信号，但这样并不高效。</p></li></ul></li></ul></li><li><p>在内核中实现</p><ul><li><p>相关实现</p><ul><li><p>内核中有用于记录系统中全部线程信息的线程表。</p></li><li><p>所有能够阻塞线程的调用都以系统调用的形式实现。当线程被阻塞时，根据内核调度器选择其他线程</p></li><li><p>由于内核中创建或撤销线程的开销较大，某些系统采用的”环保”处理方式:</p><p>​当线程被撤销时，将其标志为不可运行，但其内核数据结构并没有受到影响。随后在必须创建一个新的线程时，就重启某个旧线程，从而节省了一些开销。</p></li></ul></li><li><p>优点</p><ul><li>不需要新的、非阻塞的系统调用</li></ul></li><li><p>缺点</p><ul><li><p>开销较大</p></li><li><p>带来新的问题，如:</p><ul><li><p>多线程的进程进行fork时，应当创建一个还是多个线程?</p><p>​若调用exec启用新程序，可能单个线程更好。但若想要继续运行，则原来的线程更好。</p></li><li><p>信号到达时交由谁处理?</p><p>​传统的模型交由进程处理，但现在一个进程包含多个线程。可以让每个线程注册他们感兴趣的信号，但当多个线程注册同一个信号时应当如何处理?</p></li></ul></li></ul></li></ul></li><li><p>混合实现</p><ul><li><p>一种方法是，使用内核级线程，然后将用户级线程与某些或者全部的内核线程多路复用起来。</p><p>​这种模型带来较大的灵活度，编程人员可以决定有多少个内核级线程和用户级线程彼此多路复用。</p></li></ul></li><li><p>调度程序激活机制</p><ul><li><p>实现</p><ul><li><p>内核给每个进程安排一定数量的虚拟处理器，并且让运行时系统将线程分配到处理器上，初始为一个。进程可以申请或退回处理器，内核也可以取回。</p></li><li><p>当内核了解到一个线程被阻塞了之后，内核(通过一个已知的起始地址)通知进程的运行时系统，并在堆栈中以参数的形式传递有问题的线程编号和所发生事件的一个描述。这个机制被称为__上行调用__</p><p>一旦如此激活，运行时系统就重新调度其线程。稍后，当内核了解到原来的线程又可以运行，则再次上行调用通知运行时系统，该系统按照自己的判断继续运行或将其加入就绪表中。</p></li><li><p>当某个用户线程发生中断时，被中断的CPU切换进内核态。</p><p>​若被中断的进程对引起该中断的事件不感兴趣，则在中断处理程序结束后，将被中断的线程恢复到原状态。</p><p>​若被中断的进程对中断感兴趣，那么被中断的<strong>线程</strong>就不再启动，代之为挂起的被中断的<strong>线程</strong>。而运行时系统则启动对应的<strong>虚拟CPU</strong>，此时被中断的线程保存在<strong>堆栈</strong>(而非线程表，线程表是运行时系统维护的)中。随后运行时系统决定启动哪个线程。</p></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>About this blog</title>
    <link href="/2022/12/18/About-this-blog/"/>
    <url>/2022/12/18/About-this-blog/</url>
    
    <content type="html"><![CDATA[<h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><span id="more"></span><p>记录下第一次写博客，也是刚刚开始使用markdown</p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><p>使用<a href="https://hexo.io/zh-cn/">Hexo</a>部署在个人GitHub库中</p><p>使用<a href="https://hexo.fluid-dev.com/">Fluid</a>主题，<a href="https://hexo.fluid-dev.com/docs/start/">参考手册</a></p><p>图片借助<a href="https://picgo.github.io/PicGo-Doc/">PicGo</a>存储在个人GitHub库中</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p><del>为了整理知识</del></p><p>为了玩</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
