<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>高数</title>
    <link href="/2023/01/04/%E9%AB%98%E6%95%B0/"/>
    <url>/2023/01/04/%E9%AB%98%E6%95%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2022/12/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/12/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><h3 id="0-1-参考书目"><a href="#0-1-参考书目" class="headerlink" title="0.1. 参考书目"></a>0.1. 参考书目</h3><ul><li>现代操作系统(Modern Operating System) (第4版)</li></ul><h2 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1. 进程与线程"></a>1. 进程与线程</h2><h3 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1. 进程"></a>1.1. 进程</h3><p>​我们假设进程之间彼此是有敌意的，他们可能所属不同的用户，会相互争夺资源或相互破坏。</p><p>​<strong>用户态能访问特定的寄存器，而非不能访问，否则正常代码也不能执行。</strong></p><h4 id="1-1-1-进程的创建"><a href="#1-1-1-进程的创建" class="headerlink" title="1.1.1. 进程的创建"></a>1.1.1. 进程的创建</h4><ul><li><p>导致进程创建的4种主要事件</p><ul><li><p>系统初始化</p></li><li><p>正在运行的程序执行了创建进程的系统调用</p></li><li><p>用户请求创建一个新的进程</p><p>​如交互式系统键入命令或点击图标</p></li><li><p>一个批处理作业的初始化</p><p>​仅在大型机的批处理系统中使用，用户可以提交批处理作业。当操作系统认为资源足够运行另一个作业时，它会新建一个进程并运行输入队列的下一个作业</p></li></ul></li><li><p>地址空间</p><ul><li>在UNIX中<ul><li>不可写的内存区是共享的</li><li>或者，子进程共享父进程的所有内存，但写时复制</li></ul></li><li>在Windows中，从一开始父进程的地址空间和子进程的地址空间就是不同的</li></ul></li></ul><h4 id="1-1-2-进程的终止"><a href="#1-1-2-进程的终止" class="headerlink" title="1.1.2. 进程的终止"></a>1.1.2. 进程的终止</h4><ul><li>进程终止的原因<ul><li>正常退出</li><li>出错退出，自愿</li><li>严重错误，非自愿</li><li>被其他进程杀死</li></ul></li></ul><h4 id="1-1-3-进程的层次结构"><a href="#1-1-3-进程的层次结构" class="headerlink" title="1.1.3. 进程的层次结构"></a>1.1.3. 进程的层次结构</h4><ul><li><p>在UNIX中，树状结构</p><ul><li><p>在启动时，init出现在启动映像中，读入一个说明终端数量的文件。接着为每一个终端创建一个新进程，等待用户登录。如果有一个用户登录成功则执行一个shell</p></li><li><p>进程和其子进程组成一个进程组，用户从键盘发出的信号(如Ctrl + C)被发送给当前与键盘相关的进程组中的所有成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">pid_t</span> <span class="hljs-title function_">getpgid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span>; <span class="hljs-comment">//获取pid的进程组(进程组名一般是某个进程pid)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setpgid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">pid_t</span> pgid)</span>;  <span class="hljs-comment">//设置进程组</span><br></code></pre></td></tr></table></figure><p>一个设置进程组例子如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-type">pid_t</span> pid;<br><br>    <span class="hljs-keyword">if</span>((pid = fork()) &lt; <span class="hljs-number">0</span>)&#123;<br>        perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child: pid:%d\tgroup id:%d\n&quot;</span>, getpid(), getpgid(<span class="hljs-number">0</span>));<br>        sleep(<span class="hljs-number">3</span>);<br>        setpgid(getpid(), getpid());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child after change: pid:%d\tgroup id:%d\n&quot;</span>, getpid(), getpgid(<span class="hljs-number">0</span>));<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent: pid:%d\tgroup id:%d\n&quot;</span>, getpid(), getpgid(<span class="hljs-number">0</span>));<br>        sleep(<span class="hljs-number">2</span>);<br>        wait(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Windows中，没有进程层次的概念，所有进程地位是相同的。</p><p>​创建进程时父进程会得到一个特殊的令牌(称为句柄)，可以控制子进程。令牌可以传送给其他进程</p></li></ul><h4 id="1-1-4-进程的状态"><a href="#1-1-4-进程的状态" class="headerlink" title="1.1.4. 进程的状态"></a>1.1.4. 进程的状态</h4><p>​注意哪些状态转换不存在(如阻塞不能直接运行)</p><ul><li><p>五状态</p><p><img src="https://cdn.jsdelivr.net/gh/tsdsnk/imgs@main/img/QQ%E6%88%AA%E5%9B%BE20230105210735.png" alt="五状态"></p></li><li><p>七状态</p><p><img src="https://cdn.jsdelivr.net/gh/tsdsnk/imgs@main/img/QQ%E6%88%AA%E5%9B%BE20230105210755.png" alt="七状态"></p></li></ul><h4 id="1-1-5-进程的实现"><a href="#1-1-5-进程的实现" class="headerlink" title="1.1.5. 进程的实现"></a>1.1.5. 进程的实现</h4><ul><li><p>操作系统维护着一张表格，即进程表。每个进程占用一个表项(也称进程控制块)，记录着进程的一些状态。</p></li><li><p>对于中断发生时:</p><ul><li><p>将进程信息压入堆栈，跳转到中断向量的地址。(这些任务由<strong>硬件</strong>完成)</p></li><li><p>(跳转到的软件)将堆栈中的信息保存到进程表项中，并删除堆栈中数据。</p></li><li><p>将堆栈指针指向进程处理程序所使用的临时堆栈</p></li><li><p>C语言编写的中断服务程序</p></li><li><p>调用调度程序</p></li><li><p>为当前的进程装入寄存器值以及内存映射。</p></li></ul><p>一种可能的实现，使用信号量(PV操作):</p><p>​启动IO时进行P操作，再由中断处理程序进行V操作。</p></li></ul><h3 id="1-2-线程"><a href="#1-2-线程" class="headerlink" title="1.2. 线程"></a>1.2. 线程</h3><p>​线程同属于一个用户，因而对不同线程的资源进行保护是没有必要的。</p><h4 id="1-2-1-线程的内容"><a href="#1-2-1-线程的内容" class="headerlink" title="1.2.1. 线程的内容"></a>1.2.1. 线程的内容</h4><table><thead><tr><th>线程共享的进程内容</th><th>每个线程中的内容</th></tr></thead><tbody><tr><td>地址空间</td><td>程序计数器</td></tr><tr><td>全局变量</td><td>寄存器</td></tr><tr><td>打开文件</td><td>堆栈</td></tr><tr><td>子进程</td><td>状态</td></tr><tr><td>即将发生的定时器</td><td></td></tr><tr><td>信号与信号处理程序</td><td></td></tr><tr><td>账户信息</td><td></td></tr></tbody></table><p>​每个线程都有自己独立的堆栈，否则函数调用过程会出现混乱。</p><h4 id="1-2-2-POSIX线程"><a href="#1-2-2-POSIX线程" class="headerlink" title="1.2.2. POSIX线程"></a>1.2.2. POSIX线程</h4><p>​该标准定义的线程包叫<strong>pthread</strong>，大部分UNIX系统均支持该标准</p><p>​注意线程资源也需要回收，调用join函数会等待返回值并将该线程回收，或者调用detach使得线程分离，不会取得返回值但自动回收。</p><p>​一个例子如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_param</span>&#123;</span><br>    <span class="hljs-type">int</span> param1;<br>    <span class="hljs-type">int</span> param2;<br>&#125;Param;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">thread_func</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span>&#123;<br>    Param param = *(Param *)arg;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello from thread\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Get param: param1:%d\tparam2:%d\n&quot;</span>, param.param1, param.param2);<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    Param param;<br>    param.param1 = <span class="hljs-number">1</span>;<br>    param.param2 = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, thread_func, (<span class="hljs-type">void</span> *)&amp;param) != <span class="hljs-number">0</span>)&#123;<br>        perror(<span class="hljs-string">&quot;pthread_creat&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-3-线程的实现"><a href="#1-2-3-线程的实现" class="headerlink" title="1.2.3. 线程的实现"></a>1.2.3. 线程的实现</h4><ul><li><p>在用户空间实现</p><ul><li><p>从内核角度:</p><p>​单线程进程</p><p>在用户空间:</p><p>​存在一个运行时系统，运行时系统管理着线程表，线程在运行时系统的上层运行</p></li><li><p>优点</p><ul><li>线程调度较为快捷，因为无需陷入内核</li><li>允许每个进程有自己定制的调度算法</li><li>具有较好的扩展性。否则内核空间维护线程信息，在线程数较大时会出现问题</li></ul></li><li><p>缺点</p><ul><li><p>如何实现阻塞系统调用。阻塞系统调用会阻塞进程，即全部线程。</p><p>一种可能的替代方案:</p><p>​select系统调用可以允许调用者预知是否会引起阻塞。在系统周围从事检查的这类代码被称为<strong>包装器</strong>。但这个做法效率并不高。(大部分使用多线程的原因是经常会发生线程阻塞)</p></li><li><p>类似于阻塞的问题:缺页中断</p></li><li><p>线程必须主动放弃(yield)，否则其他线程会无法运行。</p><p>​因为在进程内部并没有时钟中断。一种方案是让运行时系统每秒请求一次时钟信号，但这样并不高效。</p></li></ul></li></ul></li><li><p>在内核中实现</p><ul><li><p>相关实现</p><ul><li><p>内核中有用于记录系统中全部线程信息的线程表。</p></li><li><p>所有能够阻塞线程的调用都以系统调用的形式实现。当线程被阻塞时，根据内核调度器选择其他线程</p></li><li><p>由于内核中创建或撤销线程的开销较大，某些系统采用的”环保”处理方式:</p><p>​当线程被撤销时，将其标志为不可运行，但其内核数据结构并没有受到影响。随后在必须创建一个新的线程时，就重启某个旧线程，从而节省了一些开销。</p></li></ul></li><li><p>优点</p><ul><li>不需要新的、非阻塞的系统调用</li></ul></li><li><p>缺点</p><ul><li><p>开销较大</p></li><li><p>带来新的问题，如:</p><ul><li><p>多线程的进程进行fork时，应当创建一个还是多个线程?</p><p>​若调用exec启用新程序，可能单个线程更好。但若想要继续运行，则原来的线程更好。</p></li><li><p>信号到达时交由谁处理?</p><p>​传统的模型交由进程处理，但现在一个进程包含多个线程。可以让每个线程注册他们感兴趣的信号，但当多个线程注册同一个信号时应当如何处理?</p></li></ul></li></ul></li></ul></li><li><p>混合实现</p><ul><li><p>一种方法是，使用内核级线程，然后将用户级线程与某些或者全部的内核线程多路复用起来。</p><p>​这种模型带来较大的灵活度，编程人员可以决定有多少个内核级线程和用户级线程彼此多路复用。</p></li></ul></li><li><p>调度程序激活机制</p><ul><li><p>实现</p><ul><li><p>内核给每个进程安排一定数量的虚拟处理器，并且让运行时系统将线程分配到处理器上，初始为一个。进程可以申请或退回处理器，内核也可以取回。</p></li><li><p>当内核了解到一个线程被阻塞了之后，内核(通过一个已知的起始地址)通知进程的运行时系统，并在堆栈中以参数的形式传递有问题的线程编号和所发生事件的一个描述。这个机制被称为<strong>上行调用</strong></p><p>一旦如此激活，运行时系统就重新调度其线程。稍后，当内核了解到原来的线程又可以运行，则再次上行调用通知运行时系统，该系统按照自己的判断继续运行或将其加入就绪表中。</p></li><li><p>当某个用户线程发生中断时，被中断的CPU切换进内核态。</p><p>​若被中断的进程对引起该中断的事件不感兴趣，则在中断处理程序结束后，将被中断的线程恢复到原状态。</p><p>​若被中断的进程对中断感兴趣，那么被中断的<strong>线程</strong>就不再启动，代之为挂起的被中断的<strong>线程</strong>。而运行时系统则启动对应的<strong>虚拟CPU</strong>，此时被中断的线程保存在<strong>堆栈</strong>(而非线程表，线程表是运行时系统维护的)中。随后运行时系统决定启动哪个线程。</p></li></ul></li></ul></li></ul><h4 id="1-2-4-弹出式线程"><a href="#1-2-4-弹出式线程" class="headerlink" title="1.2.4. 弹出式线程"></a>1.2.4. 弹出式线程</h4><p>​在分布式系统中经常使用线程。考虑处理消息到来的情况:</p><p>​传统的方法是将进程或线程阻塞在receive调用上，不过也可以这样处理:一个消息的到达导致系统创建一个处理该消息的线程，这种线程称为弹出式线程。这种线程没有历史，因而可以快速的创建，消息到达与开始处理之间的时间非常短。</p><p>​(如果支持在内核上下文中运行)，在内核空间运行弹出式线程会比在用户空间更加便利(访问所有表格和IO设备)。但其在内核空间中出错的线程会带来更大损害(如无法抢占，运行时间过长从而导致信息丢失)</p><h3 id="1-3-进程间通信"><a href="#1-3-进程间通信" class="headerlink" title="1.3. 进程间通信"></a>1.3. 进程间通信</h3><p>进程间通信主要有三个问题</p><ul><li>如何传递消息</li><li>如何确保进程在关键活动上不会出现交叉</li><li>进程间正确的执行顺序(如A等待B的执行结果)</li></ul><p>对于线程来说也是类似的，除了第一点由于共享地址空间可以较好解决。</p><p>对于一个好的对竞争条件的解决方案需要满足:</p><ul><li>任何两个进程不能同时处于临界区</li><li>不应对CPU的速度和数量做任何假设</li><li>临界区外的进程不能阻塞其他进程</li><li>不能使进程无限期等待进入临界区</li></ul><h4 id="1-3-1-忙等待的互斥"><a href="#1-3-1-忙等待的互斥" class="headerlink" title="1.3.1. 忙等待的互斥"></a>1.3.1. 忙等待的互斥</h4><p>​连续检查某一变量的方案称为忙等待，用于忙等待的锁称为<strong>自旋锁</strong>。它适用于等待时间较短的情况。</p><p>​值得注意的问题:若有两条不同优先级的进程，高优先级的进程等待低优先级进程的自旋锁，会导致高优先级永远等待下去，这种情况叫做优先级反转。</p><p>​几种实现忙等待的方法:</p><ul><li><p>屏蔽中断</p><p>在进入临界区时可以屏蔽所有中断(包括时钟中断)，但这种权力放在用户空间并不好。</p></li><li><p>严格轮换法</p><p>两个进程轮流进入临界区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-keyword">while</span>(turn != <span class="hljs-number">0</span>);<br>critical_region();\\临界区<br>turn = <span class="hljs-number">1</span>;<br>noncritical_region();<br>&#125;<br><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-keyword">while</span>(turn != <span class="hljs-number">1</span>);<br>critical_region();<br>turn = <span class="hljs-number">0</span>;<br>noncritical_region();<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方案在某一个进程快很多时，也不得不等待另一个进程，即便他们都不在临界区。</p></li><li><p>Peterson解法</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/* 假定有两个线程0,1*/</span><br><span class="hljs-type">int</span> turn;<span class="hljs-comment">// 现在轮到谁等待</span><br><span class="hljs-type">int</span> interested[<span class="hljs-number">2</span>];<span class="hljs-comment">// 谁对临界区感兴趣</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enter_region</span><span class="hljs-params">(<span class="hljs-type">int</span> process)</span></span>&#123;<br><span class="hljs-type">int</span> other = <span class="hljs-number">1</span> - process;<br>interested[process] = <span class="hljs-literal">true</span>;<br>turn = process;<br><span class="hljs-keyword">while</span>(turn == process &amp;&amp; interested[other] == <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">leave_region</span><span class="hljs-params">(<span class="hljs-type">int</span> process)</span></span>&#123;<br>interested[process] = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方案是谦让的解决方案。</p></li><li><p>TSL指令实现</p><p>这种方式需要硬件支持一条指令</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">TSL RX, <span class="hljs-keyword">LOCK</span><span class="hljs-comment">;测试并加锁</span><br></code></pre></td></tr></table></figure><p>它将内存字LOCK读入寄存器RX中，并向内存中存入一个非零值。</p><p>这个操作是不可分割的，执行该指令的CPU会锁住内存总线</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">enter_region:</span><br>TSL REG, LOCK<br>CMPREG, <span class="hljs-meta">#0</span><br>JNE enter_region<br><span class="hljs-keyword">RET</span><br><br><span class="hljs-symbol">leave_region:</span><br>MOVE LOCK, <span class="hljs-meta">#0</span><br></code></pre></td></tr></table></figure><p>一种可替代的指令XCHG，它的作用是交换寄存器和内存的内容，但也是不可分割的。</p></li></ul><h4 id="1-3-2-睡眠与唤醒"><a href="#1-3-2-睡眠与唤醒" class="headerlink" title="1.3.2. 睡眠与唤醒"></a>1.3.2. 睡眠与唤醒</h4><ul><li><p>信号量</p><p>​PV操作。P减一，为0则阻塞。V增一，若有进程因为P休眠则唤醒。</p><p>​通常将其作为系统调用使用。为保证其不可分割，操作系统需要在执行下列操作时屏蔽中断:测试信号量(P操作)，更新信号量以及在需要时使某个进程休眠。如果有多个CPU，则每个信号量应当由一个锁变量(TSL或XCHG实现)来保护(因为多个CPU时，屏蔽中断并不能阻止其他CPU访问内存)。此时自旋锁的等待代价是可以接受的。</p><p>​生产者消费者的例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> semaphore;<span class="hljs-comment">// 信号量是一种特殊的整型数据</span><br>semaphore mutex = <span class="hljs-number">1</span>;<br>semaphore empty = N;<br>semaphore full = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">producter</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-type">int</span> item;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        item = produce_item();<br>        P(&amp;empty);<br>        P(&amp;mutex);<br>        insert_item(item);<br>        V(&amp;mutex);<br>        V(&amp;full);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-type">int</span> item;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        P(&amp;full);<br>        P(&amp;mutex);<br>        item = remove_item();<br>        V(&amp;mutex);<br>        V(&amp;empty);<br>        consume_item(item);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>互斥量(mutex)</p><p>信号量的简化版本，不需要信号量的计数能力。</p><p>但在线程会与在进程的情形会有一些不同，考察如下的实现。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">mutex_lock:</span><br>TSL REG, MUTEX<br>CMP REG, <span class="hljs-meta">#0</span><br>JZE ok<br><span class="hljs-keyword">CALL</span> thread_yield<br><span class="hljs-keyword">JMP</span> mutex_look<br><span class="hljs-symbol">ok:</span><br><span class="hljs-keyword">RET</span><br><br><span class="hljs-symbol">mutex_unlock:</span><br><span class="hljs-keyword">MOV</span> MUTEX, <span class="hljs-meta">#0</span><br><span class="hljs-keyword">RET</span><br></code></pre></td></tr></table></figure><p>上面的代码中必须要调用thread_yield，否则由于线程没有时钟中断会一直运行下去。</p><p>一些线程的互斥量实现:</p><ul><li><p>快速用户区互斥量futex</p><p>主要是线程，因为进程切换一定需要陷入内核。</p><p>futex是Linux的一个特性，它实现了基本的锁(很像互斥锁)，且尽量避免陷入内核。</p><p>futex包含两部分:一个内核服务和一个用户库。</p><ul><li>内核服务提供一个等待队列(由于在内核，需要系统调用，将线程放在等待队列代价很大)</li><li>用户空间提供进程共享的通用锁变量(32bit整数锁)</li></ul><p>其获取锁逻辑如下</p><ul><li><p>线程执行原子操作减少并检查来夺取锁</p></li><li><p>没有竞争时，futex完全在用户态工作</p><p>在有竞争时，调用系统调用将等待的线程放在等待队列上。</p></li><li><p>当另一线程通过原子操作增加并检验释放锁。如果有阻塞的线程才陷入内核，没有竞争时不会陷入内核。</p></li></ul></li><li><p>pthread中的互斥量</p><p>这些锁需要初始化和销毁，见下面的例子。</p><ul><li><p>使用可以被锁定和解锁的互斥量保护临界区</p><p>进程进入时若互斥量未被加锁，则可以立即进入，同时互斥量会被锁住。</p><p>进程进入时互斥量已被锁定，则会阻塞调用线程直至其解锁。</p><p>该锁被解锁时，允许一个等待线程运行并将互斥量重新锁定</p></li><li><p>除此外，pthread提供了另一种同步机制:条件变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* 等待cond上的唤醒(后面两个函数)，进入函数时释放mutex，返回时重新获取mutex */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_wait</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond, <span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">唤醒在cond上等待的线程</span><br><span class="hljs-comment">signal唤醒一个，broadcast全部唤醒重新竞争</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_signal</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span>; <br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_broadcast</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span>;<br></code></pre></td></tr></table></figure></li></ul><p>一个生产者消费者例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 100</span><br><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><span class="hljs-type">pthread_cond_t</span> condc, condp;<br><span class="hljs-type">int</span> buffer = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">producter</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=MAX; i++)&#123;<br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-keyword">while</span>(buffer != <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">// 这里的buffer避免了条件变量丢失的情况</span><br>            pthread_cond_wait(&amp;condp, &amp;mutex);<br>        &#125;<br>        buffer = i;<br>        pthread_cond_signal(&amp;condc);<br>        pthread_mutex_unlock(&amp;mutex);<br>    &#125;<br>    pthread_exit(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=MAX; i++)&#123;<br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-keyword">while</span>(buffer == <span class="hljs-number">0</span>)&#123;<br>            pthread_cond_wait(&amp;condc, &amp;mutex);<br>        &#125;<br>        buffer = <span class="hljs-number">0</span>;<br>        pthread_cond_signal(&amp;condp);<br>        pthread_mutex_unlock(&amp;mutex);<br>    &#125;<br>    pthread_exit(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> ** argv)</span>&#123;<br>    <span class="hljs-type">pthread_t</span> pro, con;<br>    pthread_mutex_init(&amp;mutex, <span class="hljs-number">0</span>);<br>    pthread_cond_init(&amp;condc, <span class="hljs-number">0</span>);<br>    pthread_cond_init(&amp;condp, <span class="hljs-number">0</span>);<br>    pthread_create(&amp;con, <span class="hljs-number">0</span>, consumer, <span class="hljs-number">0</span>);<br>    pthread_create(&amp;pro, <span class="hljs-number">0</span>, producter, <span class="hljs-number">0</span>);<br>    pthread_join(pro, <span class="hljs-number">0</span>);<br>    pthread_join(con, <span class="hljs-number">0</span>);<br>    pthread_cond_destroy(&amp;condc);<br>    pthread_cond_destroy(&amp;condp);<br>    pthread_mutex_destroy(&amp;mutex);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="1-3-3-共享数据"><a href="#1-3-3-共享数据" class="headerlink" title="1.3.3. 共享数据"></a>1.3.3. 共享数据</h4><p>该问题在线程是较容易实现的，故仅仅讨论进程如何共享某些变量。</p><ul><li>共享数据结构，比如信号量，且只能通过系统调用来访问。</li><li>多数现代系统(如UNIX和Windows)让进程与其他进程共享部分地址空间，或使用共享文件。</li></ul><h4 id="1-3-4-管程"><a href="#1-3-4-管程" class="headerlink" title="1.3.4. 管程"></a>1.3.4. 管程</h4><p>​管程是一个语言概念，C语言并不支持管程。任意时刻管程中只能有一个活跃的进程。</p><p>​进入管程的互斥由编译器负责。当一个调用一个管程的过程时，过程的前几句会检查管程内是否有一个活跃的进程，通常的做法是用一个互斥量或二元信号量。</p><p>​同时需要一种方法使得进程在无法继续运行时阻塞，解决的方法是引入条件变量。为了避免管程中同时有两个活跃进程，我们需要指定一条规则说明在signal后应该怎么办，两种方法如下:</p><ul><li>Hoare建议让新唤醒的进程运行而挂起另一个进程</li><li>Brinch Hansen建议执行signal的进程立刻退出管程，这意味着将signal语句作为管程过程的最后一条语句。</li><li>让发信号者继续运行直至退出管程</li></ul><p>​但需要注意，条件变量并不能累积起来使用。如果向一个变量发送信号但没有等待进程，该信号会永远丢失。但是该问题可以通过设置变量很好的解决(如上面例子之中的buffer)。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">monitor ProducerConsumer<br>condition full, <span class="hljs-keyword">empty</span><span class="hljs-punctuation">;</span><br>integer count<span class="hljs-punctuation">;</span><br><br><span class="hljs-keyword">procedure</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(item: integer)</span>;<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span> count = N <span class="hljs-keyword">then</span> wait(full)<span class="hljs-punctuation">;</span><br>insert_item(item)<span class="hljs-punctuation">;</span><br>count := count + <span class="hljs-number">1</span><span class="hljs-punctuation">;</span><br><span class="hljs-keyword">if</span> count = <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> signal(<span class="hljs-keyword">empty</span>)<span class="hljs-punctuation">;</span><br><span class="hljs-keyword">end</span><span class="hljs-punctuation">;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">remove</span>: integer<span class="hljs-punctuation">;</span><br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span> count = <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> wait(<span class="hljs-keyword">empty</span>)<span class="hljs-punctuation">;</span><br><span class="hljs-keyword">remove</span> = remove_item<span class="hljs-punctuation">;</span><br>count := count - <span class="hljs-number">1</span><span class="hljs-punctuation">;</span><br><span class="hljs-keyword">if</span> count = N - <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> signal(full)<br><span class="hljs-keyword">end</span><span class="hljs-punctuation">;</span><br><br>count := <span class="hljs-number">0</span><span class="hljs-punctuation">;</span><br><span class="hljs-keyword">end</span> monitor<span class="hljs-punctuation">;</span><br><br><span class="hljs-keyword">procedure</span> <span class="hljs-title function_">producer</span>;<br><span class="hljs-keyword">begin</span> <br><span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span> <span class="hljs-keyword">do</span><br><span class="hljs-keyword">begin</span><br>item = produce_item<span class="hljs-punctuation">;</span><br>ProducerConsumer.insert(item)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><span class="hljs-punctuation">;</span><br><br><span class="hljs-keyword">procedure</span> <span class="hljs-title function_">consumer</span>;<br><span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span> <span class="hljs-keyword">do</span><br><span class="hljs-keyword">begin</span><br>item = ProducerConsumer.remove<span class="hljs-punctuation">;</span><br>consume_item(item)<span class="hljs-punctuation">;</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure><p>​这里之所以用wait和signal而非sleep与wakeup是可能出现在一个进程想睡眠时去唤醒他。在管程中则无需担心wait完成前切换到消费者。</p><p>​Java能够支持管程，使用synchronized关键字，但Java与其他经典管程有本质差别，它并没有条件变量，反之，提供了wait和notify，分别与sleep和wakeup等价。</p><h4 id="1-3-5-消息传递"><a href="#1-3-5-消息传递" class="headerlink" title="1.3.5. 消息传递"></a>1.3.5. 消息传递</h4><p>​有的时候，使用信号量太过低级，但管程又是一个语言概念。并且这些原语都为提供机器间信息交换的方法。我们可以设计两条系统调用send和receive(如send(destination, &amp;message)和receive(source, &amp;message))，前者发送消息，后者接受某个或任意源的消息，接受不到则阻塞。</p><ul><li><p>特别对于网络的情况，消息可能被丢失。因而可以达成如下一致:接收到消息后回发确认消息，若发送方未接收到确认，则重发。</p><p>需要考虑消息被正确接受但确认消息丢失，这样接收者将得到两个完全一致的消息，需要解决区分的问题。通常采用在原始信息中嵌入一个连续的序列号。</p></li><li><p>消息还需要考虑如何确定发送者和接受者，以及身份认证的问题。</p></li></ul><p>​下面是使用消息来实现生产者消费者的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-type">int</span> item;<br>    message m;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        item = produce_item();<br>        receive(consumer, &amp;m);<span class="hljs-comment">// 考虑如何编址(见下文)</span><br>        build_message(&amp;m, item);<br>        send(consumer, &amp;m);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-type">int</span> item;<br>    message m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;N; i++)&#123;<span class="hljs-comment">// 初始化N个消息</span><br>        send(producer, &amp;m);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        receive(producer, &amp;m);<br>        item = extract_item(&amp;m);<br>        send(producer, &amp;m);<br>        consume_item(item);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到上面的例子之中需要考虑如何对消息进行编址</p><ul><li>为每一个进程分配一个唯一的地址</li><li>引入一种新的数据结构，信箱，用于缓冲一定量的消息。此时send和receive使用的是信箱的地址。</li></ul><p>当(信箱)极端的，彻底取消缓冲。send在receive之前则send阻塞，receive在send之前，receive阻塞，则称为会合。</p><h4 id="1-3-6-屏障"><a href="#1-3-6-屏障" class="headerlink" title="1.3.6.屏障"></a>1.3.6.屏障</h4><p>​对于一组进程而言，需要在某个阶段结尾使其达到同步，则在此安置屏障。</p><p>​如实现某大矩阵乘法需将其并行计算迭代时。</p><h4 id="1-3-7-读-复制-更新"><a href="#1-3-7-读-复制-更新" class="headerlink" title="1.3.7. 读-复制-更新"></a>1.3.7. 读-复制-更新</h4><p>为了避免锁，使某个进程读的全部为旧值或全部为新值。如下例</p><p>新增节点</p><p><img src="https://cdn.jsdelivr.net/gh/tsdsnk/imgs@main/img/QQ%E5%9B%BE%E7%89%8720230107212343.png"></p><p>删除节点(当对A,B没有更多读操作时才可以删除)</p><p><img src="https://cdn.jsdelivr.net/gh/tsdsnk/imgs@main/img/QQ%E5%9B%BE%E7%89%8720230107213045.png"></p><p>但是多长时间所有读操作才会读完这些节点，可以规定一个最大引用(该树)时间。如果在读端临界区规定不能够阻塞或休眠，则只需等待所有读操作完成一次上下文切换即可。</p><h3 id="1-4-调度"><a href="#1-4-调度" class="headerlink" title="1.4. 调度"></a>1.4. 调度</h3><p>$$<br>\begin{aligned}<br>&amp; T_{周转时间} &#x3D; T_{完成时间} - T_{到达时间} \<br>&amp; T_{响应时间} &#x3D; T_{开始时间} - T_{到达时间}<br>\end{aligned}<br>$$</p><h4 id="1-4-1-批处理系统"><a href="#1-4-1-批处理系统" class="headerlink" title="1.4.1. 批处理系统"></a>1.4.1. 批处理系统</h4><ul><li><p>先来先服务</p><ul><li>易于理解以及应用</li><li>不能协调计算密集型和I&#x2F;O密集型</li></ul></li><li><p>最短作业优先(非抢占)</p><p>​此方法一般需要预知作业时间。在大型批处理系统中，如保险公司处理索赔的一批作业，由于每天都在做类似工作因而可以精确预测。</p><p>​此方法可使得平均周转时间最短，如时间为$a,b,c,d$的四个作业，平均周转时间为$\frac{1}{4}(4a+3b+2c+d)$</p></li><li><p>最短剩余作业优先(抢占式)</p><p>​仍需要预知时间</p></li></ul><h4 id="1-4-2-交互式系统"><a href="#1-4-2-交互式系统" class="headerlink" title="1.4.2. 交互式系统"></a>1.4.2. 交互式系统</h4><ul><li><p>轮转调度</p><p>​核心为时间片的长短，平衡切换代价及响应时间</p></li><li><p>优先级调度</p><ul><li><p>为了防止高优先级无休止运行</p><ul><li>可以在每次时钟中断之后降低优先级</li><li>可以为每个进程赋予一个允许运行的最大时间片，用完这个时间片则允许次高优先级</li></ul></li><li><p>优先级也可以由系统动态确定</p><p>​如为了尽可能使I&#x2F;O密集型提前工作，当这样的进程需要CPU时应立即分给他CPU。一种算法是，将每个进程赋予优先级$\frac{1}{f}$，$f$是该进程在上一次时间片中所占的部分。</p></li></ul></li><li><p>多级队列</p><p>早期内存只能存放一个进程，出现进程切换速度较慢的情况。</p><p>此时为CPU密集型进程分配长时间片比分配短时间片效率较高，但长时间片又会影响到响应时间，因而提出了如下的解决办法:</p><p>​为高优先级分配1个时间片，次高分配2个，4个，以此类推(由于I&#x2F;O密集型具有较高的优先级)。当进程用完则被分到下一优先级。对于一些开始时运行较长时间而后需要交互的进程，为了防止其一直处于被惩罚的状态，可以在终端上每次按下回车键时将其转移到最高优先级。</p></li><li><p>最短进程优先</p><p>仍然需要预知时间。</p><p>​一种办法是根据过去行为推测。记当前估计为$T_i$，测量到其下次运行时间为$t_{i+1}$，则更新估计时间为$\alpha T_i + (1 - \alpha)t_{i+1}$</p></li><li><p>保证算法</p><p>​保证每个用户能获得CPU的$\frac{1}{n}$，跟踪自进程创建以来使用的CPU时间，计算其应获得的CPU。运行二者之比最低的进程直至其超过最接近的竞争者</p></li><li><p>彩票调度</p><p>​为每个进程分配彩票，调用拥有选中彩票的进程。</p><p>​这种调度在有新进程时是反应迅速的。它也可以按比例划分CPU的使用</p></li><li><p>公平分享</p><p>​不仅仅考虑进程，而是考虑用户，每个用户有相同的机会，然后才去调度用户所拥有的进程</p></li></ul><h4 id="1-4-3-实时系统"><a href="#1-4-3-实时系统" class="headerlink" title="1.4.3. 实时系统"></a>1.4.3. 实时系统</h4><p>​实时系统通常分为硬实时和软实时。前者必须满足绝对的截止时间，而后者可以容忍偶尔错失的截止时间。</p><p>​实时系统中的事件可以划分为周期性的和非周期性的。对于周期性事件$i$，以周期$P_i$发生，需要处理时间为$C_i$，则只有满足如下条件时才能处理负载，即这个系统是可调度的:<br>$$<br>\sum_{i&#x3D;1}^m \frac{C_i}{P_i} \leq 1<br>$$<br>​实时系统的调度可以是静态的，也可以是动态的。</p><h4 id="1-4-4-策略和机制"><a href="#1-4-4-策略和机制" class="headerlink" title="1.4.4. 策略和机制"></a>1.4.4. 策略和机制</h4><p>​我们可以使得调度策略和调度机制分离，也就是将调度算法以某种形式参数化，而参数让用户进程填写。</p><p>​如内核使用优先级调度算法，并提供了可以改变优先级的系统调用。这样尽管父进程本身并不参与调度，但他可以制定调度子进程的策略。</p><h4 id="1-4-5-线程调度"><a href="#1-4-5-线程调度" class="headerlink" title="1.4.5. 线程调度"></a>1.4.5. 线程调度</h4><ul><li><p>用户线程</p><p>用户线程的调度由运行时系统决定，可以选择上述算法的任何一种，但缺乏时钟中断，内核并不知道线程的存在。</p></li><li><p>内核级线程</p><p>对于某个线程被阻塞，对于同等重要的线程，最好倾向于同一进程以减小切换开销。但内核也可以不考虑线程所属的进程</p></li></ul><h3 id="1-5-经典的IPC问题"><a href="#1-5-经典的IPC问题" class="headerlink" title="1.5. 经典的IPC问题"></a>1.5. 经典的IPC问题</h3><h4 id="1-5-1-哲学家就餐问题"><a href="#1-5-1-哲学家就餐问题" class="headerlink" title="1.5.1. 哲学家就餐问题"></a>1.5.1. 哲学家就餐问题</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-comment">#define N5</span><br><span class="hljs-comment">#define LEFT(i+N-1) % N</span><br><span class="hljs-comment">#define RIGHT(i+1) % N</span><br><span class="hljs-comment">#define THINKING0</span><br><span class="hljs-comment">#define HUNGRY1</span><br><span class="hljs-comment">#define EATING2</span><br>typedef int segmaphore;<br>int <span class="hljs-keyword">state</span>[N];<br>semaphore mutex = <span class="hljs-number">1</span>;<br>semaphore s[N];<br><br>void philosopher(int i)&#123;<br>while(true)&#123;<br>// 哲学家进程<br>&#125;<br>&#125;<br><br>void take_forks(int i)&#123;<br>P(&amp;mutex);<br><span class="hljs-keyword">state</span>[i] = HUNGRY;<br>test(i);<br>V(&amp;mutex);<br>P(&amp;s[i]);<br>&#125;<br><br>void put_fork(int i)&#123;<br>P(&amp;mutex);<br><span class="hljs-keyword">state</span>[i] = THINKING;<br>test(LEFT);// 检查左右是否可以吃(唤醒)<br>test(RIGHT);<br>up(&amp;mutex);<br>&#125;<br><br>void test(int i)&#123;<br>if(<span class="hljs-keyword">state</span>[i] == HUNGRY &amp;&amp; <span class="hljs-keyword">state</span>[LEFT] != EATING &amp;&amp; <span class="hljs-keyword">state</span>[RIGHT] != EATING)&#123;<br><span class="hljs-keyword">state</span>[i] = EATING;<br>V(&amp;s[i]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-5-2-读者-写者问题"><a href="#1-5-2-读者-写者问题" class="headerlink" title="1.5.2. 读者-写者问题"></a>1.5.2. 读者-写者问题</h4><p>当写者进入时，其他进程禁止进入。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">typedef <span class="hljs-built_in">int</span> semaphore;<br>semaphore mutex = <span class="hljs-number">1</span>;<br>semaphore db = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span> rc = <span class="hljs-number">0</span>;<span class="hljs-comment">// 正在读或写的进程数目</span><br>void reader(void)&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-constructor">P(&amp;<span class="hljs-params">mutex</span>)</span>;<br>rc = rc + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(rc<span class="hljs-operator"> == </span><span class="hljs-number">1</span>)&#123;<br><span class="hljs-constructor">P(&amp;<span class="hljs-params">db</span>)</span>;<br>&#125;<br><span class="hljs-constructor">V(&amp;<span class="hljs-params">mutex</span>)</span>;<br>read<span class="hljs-constructor">_data_base()</span>;<br><span class="hljs-constructor">P(&amp;<span class="hljs-params">mutex</span>)</span>;<br>rc = rc - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(rc<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br><span class="hljs-constructor">V(&amp;<span class="hljs-params">db</span>)</span>;<br>&#125;<br><span class="hljs-constructor">V(&amp;<span class="hljs-params">mutex</span>)</span>;<br>use<span class="hljs-constructor">_data_read()</span>;<br>&#125;<br>&#125;<br><br>void writer(void)&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>think<span class="hljs-constructor">_up_data()</span>;<br><span class="hljs-constructor">P(&amp;<span class="hljs-params">db</span>)</span>;<span class="hljs-comment">// 这里不需要mutex是因为reader中rc==1会P(&amp;db)</span><br>write<span class="hljs-constructor">_data_base()</span>;<br><span class="hljs-constructor">V(&amp;<span class="hljs-params">db</span>)</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h2>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>About this blog</title>
    <link href="/2022/12/18/About-this-blog/"/>
    <url>/2022/12/18/About-this-blog/</url>
    
    <content type="html"><![CDATA[<h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><p>记录下第一次写博客，也是刚刚开始使用markdown</p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><p>使用<a href="https://hexo.io/zh-cn/">Hexo</a>部署在个人GitHub库中</p><p>使用<a href="https://hexo.fluid-dev.com/">Fluid</a>主题，<a href="https://hexo.fluid-dev.com/docs/start/">参考手册</a></p><p>图片借助<a href="https://picgo.github.io/PicGo-Doc/">PicGo</a>存储在个人GitHub库中</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p><del>为了整理知识</del></p><p>为了玩</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
